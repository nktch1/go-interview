# Подготовка к собеседованию на позицию GoLang разработчика

[Ссылка на статью с вопросами](https://medium.com/@victor_nerd/golang-interview-questions-bd3064f2ff69)

### Общие вопросы
##### Отличие протоколов TCP и UDP
В протоколе TCP доставка пакетов гарантирована, в UDP - нет. UDP асинхронно отправляет запросы и не дожидается ответов, за счет чего, в некоторых случаях, оказывается наиболее приоритетным выбором. Например, видео-, аудиоконференции, телефония и тд. 

##### Можно ли убить поток внутри определенного процесса командой ```kill``` ?
Чтобы посмотреть потоки процесса, можно воспользоваться утилитой ```ps```
```
$ ps -e -T | grep myp | grep -v grep
797   797 ?        00:00:00 myp
797   798 ?        00:00:00 myp
797   799 ?        00:00:00 myp
797   800 ?        00:00:00 myp
```
> Потоки являются неотъемлемой частью процесса и не могут быть уничтожены извне. Существует функция ```pthread_kill```, но она применяется только в контексте самого потока.

##### Как можно отсортировать файл на 100GB, в котором расположены числа в случайном порядке, по 1 числу на строку? Ограничения — объем ОЗУ на машине составляет 1GB

##### Какая твоя любимая технология? Почему?
Тут хочу написать про ClickHouse и дедупликацию

##### Какие решения ты бы принял, будучи техническим директором на своем текущем/прошлом месте работы?

##### Какую тему ты бы сам хотел обсудить?

### Вопросы по Golang
#####  Что из себя представляет тип данных ```string``` в языке Golang? Можно ли изменить определенный символ в строке? Что происходит при склеивании строк?
Строки в Go иммутабельны. При конкатенации создается новый объект типа ```string```.

##### Что будет происходить при конкурентной записи в map? Как можно решить эту проблему?
При конкуретной записи в ```map``` возникнет состояние гонки данных. Это решается использованием примитивов синхронизации. Например, mutex.

##### Нужно ли блокировать доступ к структуре мьютексом, если идет конкурентная запись в разные поля структуры?
Доступ к структуре при конкурентном доступе необязательно делать исключительным. Потому как поля структуры являются отдельными переменными, доступ из разных потоков к разным переменным будет потокобезопасным.

При исключительном доступе к структуре возможна проблема с производительностью. Рядом расположенные переменные в памяти (например поля структуры) делят кэшлайн. Кэшлайн это наименьшая область памяти, которую могут блокировать современные процессоры. Это означает, что CPU2 вынужден ждать для записи пока CPU1 не закончит использование кэшлайна (и это даже в случае записи в разные переменные). 
Эта проблема получила название **false sharing**.

И еще:

> It is NOT safe to change the pointer to the struct while writing to the struct from different threads. In your example if you had a third goroutine that did apple = &Apple{} some of the other goroutines in other threads might write to the old Apple or the new Apple and you wouldn't know.



Соглашение:
> Используйте ```defer``` при разблокировке, если у функции есть несколько точек выхода. 
>
> Определяя структуру, в которой мьютекс должен защищать одно или больше значений, помещайте мьютекс выше тех полей, доступ к которым, он будет защищать.
```
var sum struct {
    sync.Mutex     // <-- мьютекс защищает
    i int          // <-- поле под защитой мьютекса
}
```
> Точная (fine-grained) блокировка может давать лучшую производительность ценой более сложного кода для управления ею, в то время, как более грубая блокировка может быть менее производительна, но делать код проще.
>
> Хорошей практикой является инкапсулировать используемый метод синхронизации. Пользователи вашего пакета не должны заботится, каким именно образом вы защищаете данные в вашем коде.

    Мьютексы в GoLang не рекурсивны!

##### Какая есть проблема в коде?
```
var counter int
for i := 0; i < 1000; i++ {
   go func() {
      counter++
   }()
}
```

Проблема №1: нет ожидания завершения горутин, проблема №2: доступ к счетчику на запись из разных горутин приводит к гонке данных.

Решение:
```
var (
    counter int
    wg = &sync.WaitGroup{}
    mu = &sync.Mutex{}
)

wg.Add(1000)

for i := 0; i < 1000; i++ {
    go func() {
        defer wg.Done()
        mu.Lock()
        counter++
        mu.Unlock()
    }()
}

wg.Wait()
```

Решение без использования пакета ```sync```:
```
var (
    counter int
    done    = make(chan struct{}, TaskCount)
    mu      = make(chan struct{}, 1)
    t       = time.Now()
)

mu <- struct{}{}

for i := 0; i < TaskCount; i++ {
    go func() {
        <-mu
        counter++

        done <- struct{}{}
        mu <- struct{}{}
    }()
}

var readyTasksCounter int
for range done {
    readyTasksCounter++

    if readyTasksCounter == TaskCount {
        break
    }
}
```

##### Можно ли реализовать sync.Mutex и sync.WaitGroup на каналах? Как?
Можно. 
Для ```sync.WaitGroup``` потребуется буферизованый канал размером равный количеству задач. Каждый раз при завершении горутины нужно записывать в этот канал значение. Это будет означать, что задача выполнена. В отдельной горутине нужно читать из канала с сигналами о завершении, и, в случае, когда количество прочитанных сообщений совпадет с количеством задач, выйти из цикла.   

Для ```sync.Mutex``` нужен канал c```len == 1```, при старте программы нужно передать туа значение, чтобы не было дедлока. При старте выполнения задачи необходимо "вытащить билет" прочитать из канала значение, а при завершении - записать в канал. Все что находится в секции между чтением и записью в этот канал будет выполнено с соблюдением синхронно.

##### Что ты использовал из пакета ```sync``` (кроме ```Mutex``` и ```WaitGroup```)?
- once
- map
- conditional variables
- RW mutex
- pool

##### За сколько примерно выполнится приложение — за 3 секунды или за 6?

```
func worker() chan int {
   ch := make(chan int)

   go func() {
      time.Sleep(3 * time.Second)
      ch <- 42
   }()

   return ch
}

func main() {
   timeStart := time.Now()

   _, _ = <-worker(), <-worker()

   println(int(time.Since(timeStart).Seconds())) // что выведет - 3 или 6?
}
```

Выполнится за 6с, потому что выполнение второй горутины произойдет только после завершения первой. Если запустить их одновременно, то код выполнится за 3с.
```
func worker(res chan int){
	//ch := make(chan int)

	go func() {
		time.Sleep(3 * time.Second)
		res <- 42
	}()
}

func f3() {
	timeStart := time.Now()
	ch := make(chan int)

	worker(ch)
	worker(ch)

	//_, _ = <-worker(ch), <-worker(ch)
	_, _ = <-ch, <-ch

	println(int(time.Since(timeStart).Seconds())) // что выведет - 3 или 6?
}
```